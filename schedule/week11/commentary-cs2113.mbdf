{% from "common/topics.njk" import panopto, slugify, topic_followup, topic_preamble with context %}

{% call topic_preamble("Architecture", reuse=false) %}
**While _architecture_ is not of high importance to a small project such as the tP, it is good to know a little bit about it** in case you are thrown into a larger project in future.
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("designApproaches-multilevelDesign-what", reuse=false) %}
**First, let us learn about multi-level design**, a pre-cursor to learning about architecture.
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("architecture-introduction-what", reuse=false) %}
Now that we know about multi-level design, let us learn about architecture, which is a special case of multi-level design. We also cover _architecture diagrams_ here.
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("Architectural Styles", reuse=false) %}
Remember _design patterns_? The _architectural styles_ covered below are like 'design patterns' at architecture level. As before, we only cover two of them just to give you a taste of the topic while keeping the workload low.
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("Types of Testing", reuse=false) %}
As we approach the last part of the tP, we'll be spending more time learning about software testing. This week, we start off with an overview of different _types_ of software testing.
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("testing-dependencyInjection-what", reuse=false) %}
_Dependency Injection_ is a technique closely related to stubs. It is not in the syllabus but is given below in case some of you would like to know more about it.
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("Test Case Design", reuse=false) %}
Last week, we learned how to measure test _coverage_. This week, we look into how to increase coverage with the least number of test cases.

First, we take a look at test case design in general, different approaches to test case design, and few different categorization of test cases.
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("testCaseDesign-introduction-what", reuse=false) %}
**What is _test case design_, and why should we care?**

{{ panopto("bd513fd6-8ccb-4bb3-8467-ab8d009a8de0") }}
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("testCaseDesign-introduction-blackVsGlass", reuse=false) %}
**How much information about the code is being used when designing test cases?**

{{ panopto("8221a124-fe08-4c48-8a72-ab8d00aa53d3") }}
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("Equivalence Partitioning", reuse=false) %}
Our syllabus includes two specific techniques for improving test case design. This week, we cover one of them: _equivalence partitioning_.
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("testCaseDesign-equivalencePartitions-what", reuse=false) %}
{{ panopto("59a122d2-7170-4aea-9888-ab8d00b850ed") }}
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->
{% call topic_preamble("testCaseDesign-equivalencePartitions-basic", reuse=false) %}
{{ panopto("83001c05-69fb-4322-b571-ab8d00cd4337") }}
{% endcall %}
<!-- ---------------------------------------------------------------------------- -->